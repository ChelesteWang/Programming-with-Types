# 类型与编程系统-读书笔记

## 章一：类型简介

- 类型检查帮助开发者写出更好更安全的代码
  - Elm、Idris语言的类型系统
- 为什么存在类型
  - 在机器码层级，程序的逻辑代码和数据（变量值）是通过位来表示的，在这一层级上代码与数据并没有区别，所以发生二者的混淆时就会出现崩溃以及可利用的漏洞（系统将数据作为代码执行，XSS？）
  - 如何解释一条数据？
    - 16位序列1100001010100011可以表示无符号16位整数49827，带符号整数-15709，UTF-8编码的字符'£'，由于数据均会被存储为位，那就需要另外一层来实际的赋予意义
    - 而类型能够为数据赋予意义，通过限制变量可用的有效值的集合（-15709）来告知软件如何解释给定的位序列，如 16 位整数被限制在某一整数范围，不允许在运行时出现无效的值
    - 在使用 const 声明、标记实例成员为 private 时系统会实施额外的安全措施
  - 对类型与类型系统的定义：1.1.2
    - 类型：限制了数据的可用操作、意义、允许的值的集合（访问限制）
    - 类型系统：一组为变量、函数等结构分配、实施类型的规则，通过显式指定或类型推导分配类型
    - 类型检查：确保程序遵守规则，编译器在编译时进行，运行时在执行时进行。其中专门负责的组件：类型检查器
      - 类型检查失败：编译失败、运行时错误
  - 类型检查与证明：
    - 类型可视为一个逻辑命题，类型的值相当于证明命题为真的论据
- 类型系统的优点
  - TC确保不会把被声明为数字的变量的数据解释为字符串，以及不会错误的引用私有变量、修改只读数据（虽然数据本身在内存中也和公有可变数据无差异）
  - 将可能造成影响的运行时错误转换为无害的、提前的编译时错误
  - 通过限制变量的可用值的集合，来减小可能的状态空间
  - 通过健全的类型系统能够提升安全性，但，很明显目前 TS 还做不到这一点
- 不可变性
  - 进一步减少出错的概率，如在通过检查后还发生了新的变化，那么检查就没有意义了
  - 编译器能够内联不可变的变量来生成更高效的代码（如函数式语言中的不可变）
    - 但也意味着得要复制数据而不能直接操作
  - 通过 封装 + private ，来实现限制非公有的信息（setter）暴露
- 组合型
- 可读性
  - 明确指定类型！
- 类型系统的检查
  - 静态：编译时检查
  - 动态：运行时检查：类型不匹配将导致运行时错误
  - 强类型系统组也存在着极少的隐式类型转换
  - 鸭子类型：只需要有这个属性即认为实现，而无需显式的让类实现这个接口
  - 执行的隐式转换越多，类型系统约束越弱
  - 强类型系统会为其认为安全的转换提供有限的支持，如转布尔值
- 类型推断
  - 仍然是在编译时检查，只不过检查前多了判断
  - 对于隐式的any类型（模糊类型）给出错误

## 章二：基本类型

- 基本类型的细节：布尔类型短路、数值溢出

- 空类型：never！

  - 此类型的可用取值集合是一个空集（比如不相交的类型的交集也是空集，即 never）

  - 函数不返回的原因：

    - 所有路径都抛出异常
    - 可能退出程序
    - 无限循环

  - 与 void 不同，void 标识不存在有意义的值

  - 空枚举，仅具有私有构造函数的类

  - 一个不可赋值的类（不能实例化）

    ```typescript
    declare const EmptyType: unique symbol;
    
    class Empty {
      [EmptyType]: void;
      private constructor(){ }
    }
    
    function throw(): Empty {
      throw new Error()
    }
    ```

- 单元类型：void

  - 某些不返回有意义的值的函数，其被调用是为了副作用

  - 单元类型只允许有一个值，因此检查其值是无意义的，即函数结果无意义时应使用单元类型

  - 自定义单元类型：

    - 只有一个元素的枚举、无状态的单例

    - 单元类型只有一个可能的取值，所以这个值是什么其实并不重要；所有单元类型都是相等的。将一个单元类型转换为另一个单元类型并没有太大意义，因为只存在一个选项：一个类型的单个值映射到另一个类型的单个值。

    - 实现无状态的单例

    - ```typescript
      declare const UnitType: unique symbol;
      
      class Unit {
        [UnitType]: void;
        // 唯一能够创建的 Unit 示例
        static readonly value: Unit = new Unit();
        private constructor(){ }
      }
      
      function throw(): Unit {
        return Unit.value;
      }
      ```

- 布尔逻辑与短路

  - 短路优化： a && b -> if a then b else false   a || b -> if a then true else b
    - 即，预先执行开销较小的检查，来避免可能的开销较大的检查

- 数值类型、浮点数类型

  - 跳过先

- 字符串类型

  - 不可轻率的在边界拆分文本（TC39 不是有个 segments 提案嘛）

- 数组和引用类型

  - 基于其构建更高级的类型结构
  - 基于访问模式与数据密度来决定最佳的使用方式
  - 变长数组：固定数组 + 引用
    - 固定数组代表连续的内存区域
    - 变长时，需要分配一个新数组并复制原数组，而在链表中可以直接追加
  - 数组中的值是依次存储的，访问任何一个值都非常快
    - 对于链表，需要从头指针开始沿着 next 访问节点，而节点地址不一定是依次连续分配的，在内存中可能需要多次翻页
  - 引用类型
    - 引用类型的值即变量的位
    - 高效列表：使用基本类型实现（长度动态变换）
      - 使用链表实现：+-节点时无需复制，但存在遍历的开销
      - 使用数组实现：高效访问，追加开销大（分配新数组）
      - 实践：具有额外容量的数组，填满时分配一个两倍容量的数组
        - 额外的内存开销
    - 二叉树
      - 使用数组实现：如果数是稀疏的，就需要额外的空间（1, , 3, ,），通常要借助引用来使用更加紧凑的表示
    - 关联数组（字典、哈希表）：键值对集合



## 章三：组合

- 复合类型、多选一、代数数据类型
- 组合类型：对各个可能的取值排列组合
- 元组类型：特殊的分组数据的方式，将不同类型的多个值作为一个值传递
  - 元组也可以通过自己创建 Class，总之就是内容类型固定？
- 记录类型：通过键名来访问，Record！
  - 元组可能造成错误的解释
- 不变量：使成员私有，但提供修改的方法对外暴露
  - 对值的校验与异常处理
- 组合类型
  - 感觉有点像模板字符串类型的配列组合？
- 枚举
- 可选类型
  - T | undefined，即 Optional？
    - 保存类型 T 的一个值或使用一个特殊值在 T 不存在时兜底
  - nullable
  - 清晰地区分可为空的情况
  - 不要让 null 成为类型的子集
- Either 类型
  - 要么返回错误，要么返回结果
- 变体类型
  - 即可辨识联合类型
    - 可辨识属性 >>> 类型索引
- 访问者模式
- 代数数据类型：AlgebraicData Type
  - 乘积类型：元组、记录  A * B * C 进行组合
  - 和类型：联合类型 A | B（也可以通过 never 实现）
