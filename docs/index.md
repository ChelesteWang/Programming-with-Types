# 类型与编程系统-读书笔记

## 章一

- 类型检查帮助开发者写出更好更安全的代码
  - Elm、Idris语言的类型系统
- 为什么存在类型
  - 在机器码层级，程序的逻辑代码和数据（变量值）是通过位来表示的，在这一层级上代码与数据并没有区别，所以发生二者的混淆时就会出现崩溃以及可利用的漏洞（系统将数据作为代码执行，XSS？）
  - 如何解释一条数据？
    - 16位序列1100001010100011可以表示无符号16位整数49827，带符号整数-15709，UTF-8编码的字符'£'，由于数据均会被存储为位，那就需要另外一层来实际的赋予意义
    - 而类型能够为数据赋予意义，通过限制变量可用的有效值的集合（-15709）来告知软件如何解释给定的位序列，如 16 位整数被限制在某一整数范围，不允许在运行时出现无效的值
    - 在使用 const 声明、标记实例成员为 private 时系统会实施额外的安全措施
  - 对类型与类型系统的定义：1.1.2
    - 类型：限制了数据的可用操作、意义、允许的值的集合（访问限制）
    - 类型系统：一组为变量、函数等结构分配、实施类型的规则，通过显式指定或类型推导分配类型
    - 类型检查：确保程序遵守规则，编译器在编译时进行，运行时在执行时进行。其中专门负责的组件：类型检查器
      - 类型检查失败：编译失败、运行时错误
  - 类型检查与证明：
    - 类型可视为一个逻辑命题，类型的值相当于证明命题为真的论据
- 类型系统的优点
  - TC确保不会把被声明为数字的变量的数据解释为字符串，以及不会错误的引用私有变量、修改只读数据（虽然数据本身在内存中也和公有可变数据无差异）
  - 将可能造成影响的运行时错误转换为无害的、提前的编译时错误
  - 通过限制变量的可用值的集合，来减小可能的状态空间
  - 通过健全的类型系统能够提升安全性，但，很明显目前 TS 还做不到这一点
- 不可变性
  - 进一步减少出错的概率，如在通过检查后还发生了新的变化，那么检查就没有意义了
  - 编译器能够内联不可变的变量来生成更高效的代码（如函数式语言中的不可变）
    - 但也意味着得要复制数据而不能直接操作
  - 通过 封装 + private ，来实现限制非公有的信息（setter）暴露
- 组合型
- 可读性
  - 明确指定类型！
- 类型系统的检查
  - 静态：编译时检查
  - 动态：运行时检查：类型不匹配将导致运行时错误
  - 强类型系统组也存在着极少的隐式类型转换
  - 鸭子类型：只需要有这个属性即认为实现，而无需显式的让类实现这个接口
  - 执行的隐式转换越多，类型系统约束越弱
  - 强类型系统会为其认为安全的转换提供有限的支持，如转布尔值
- 类型推断
  - 仍然是在编译时检查，只不过检查前多了判断
  - 对于隐式的any类型（模糊类型）给出错误