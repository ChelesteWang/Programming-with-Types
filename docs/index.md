# 类型与编程系统-读书笔记

## 章一：类型简介

- 类型检查帮助开发者写出更好更安全的代码
  - Elm、Idris语言的类型系统
- 为什么存在类型
  - 在机器码层级，程序的逻辑代码和数据（变量值）是通过位来表示的，在这一层级上代码与数据并没有区别，所以发生二者的混淆时就会出现崩溃以及可利用的漏洞（系统将数据作为代码执行，XSS？）
  - 如何解释一条数据？
    - 16位序列1100001010100011可以表示无符号16位整数49827，带符号整数-15709，UTF-8编码的字符'£'，由于数据均会被存储为位，那就需要另外一层来实际的赋予意义
    - 而类型能够为数据赋予意义，通过限制变量可用的有效值的集合（-15709）来告知软件如何解释给定的位序列，如 16 位整数被限制在某一整数范围，不允许在运行时出现无效的值
    - 在使用 const 声明、标记实例成员为 private 时系统会实施额外的安全措施
  - 对类型与类型系统的定义：1.1.2
    - 类型：限制了数据的可用操作、意义、允许的值的集合（访问限制）
    - 类型系统：一组为变量、函数等结构分配、实施类型的规则，通过显式指定或类型推导分配类型
    - 类型检查：确保程序遵守规则，编译器在编译时进行，运行时在执行时进行。其中专门负责的组件：类型检查器
      - 类型检查失败：编译失败、运行时错误
  - 类型检查与证明：
    - 类型可视为一个逻辑命题，类型的值相当于证明命题为真的论据
- 类型系统的优点
  - TC确保不会把被声明为数字的变量的数据解释为字符串，以及不会错误的引用私有变量、修改只读数据（虽然数据本身在内存中也和公有可变数据无差异）
  - 将可能造成影响的运行时错误转换为无害的、提前的编译时错误
  - 通过限制变量的可用值的集合，来减小可能的状态空间
  - 通过健全的类型系统能够提升安全性，但，很明显目前 TS 还做不到这一点
- 不可变性
  - 进一步减少出错的概率，如在通过检查后还发生了新的变化，那么检查就没有意义了
  - 编译器能够内联不可变的变量来生成更高效的代码（如函数式语言中的不可变）
    - 但也意味着得要复制数据而不能直接操作
  - 通过 封装 + private ，来实现限制非公有的信息（setter）暴露
- 组合型
- 可读性
  - 明确指定类型！
- 类型系统的检查
  - 静态：编译时检查
  - 动态：运行时检查：类型不匹配将导致运行时错误
  - 强类型系统组也存在着极少的隐式类型转换
  - 鸭子类型：只需要有这个属性即认为实现，而无需显式的让类实现这个接口
  - 执行的隐式转换越多，类型系统约束越弱
  - 强类型系统会为其认为安全的转换提供有限的支持，如转布尔值
- 类型推断
  - 仍然是在编译时检查，只不过检查前多了判断
  - 对于隐式的any类型（模糊类型）给出错误

## 章二：基本类型

- 基本类型的细节：布尔类型短路、数值溢出

- 空类型：never！

  - 此类型的可用取值集合是一个空集（比如不相交的类型的交集也是空集，即 never）

  - 函数不返回的原因：

    - 所有路径都抛出异常
    - 可能退出程序
    - 无限循环

  - 与 void 不同，void 标识不存在有意义的值

  - 空枚举，仅具有私有构造函数的类

  - 一个不可赋值的类（不能实例化）

    ```typescript
    declare const EmptyType: unique symbol;
    
    class Empty {
      [EmptyType]: void;
      private constructor(){ }
    }
    
    function throw(): Empty {
      throw new Error()
    }
    ```

- 单元类型：void

  - 某些不返回有意义的值的函数，其被调用是为了副作用

  - 单元类型只允许有一个值，因此检查其值是无意义的，即函数结果无意义时应使用单元类型

  - 自定义单元类型：

    - 只有一个元素的枚举、无状态的单例

    - 单元类型只有一个可能的取值，所以这个值是什么其实并不重要；所有单元类型都是相等的。将一个单元类型转换为另一个单元类型并没有太大意义，因为只存在一个选项：一个类型的单个值映射到另一个类型的单个值。

    - 实现无状态的单例

    - ```typescript
      declare const UnitType: unique symbol;
      
      class Unit {
        [UnitType]: void;
        // 唯一能够创建的 Unit 示例
        static readonly value: Unit = new Unit();
        private constructor(){ }
      }
      
      function throw(): Unit {
        return Unit.value;
      }
      ```

- 布尔逻辑与短路

  - 短路优化： a && b -> if a then b else false   a || b -> if a then true else b
    - 即，预先执行开销较小的检查，来避免可能的开销较大的检查

- 数值类型、浮点数类型

  - 跳过先

- 字符串类型

  - 不可轻率的在边界拆分文本（TC39 不是有个 segments 提案嘛）

- 数组和引用类型

  - 基于其构建更高级的类型结构
  - 基于访问模式与数据密度来决定最佳的使用方式
  - 变长数组：固定数组 + 引用
    - 固定数组代表连续的内存区域
    - 变长时，需要分配一个新数组并复制原数组，而在链表中可以直接追加
  - 数组中的值是依次存储的，访问任何一个值都非常快
    - 对于链表，需要从头指针开始沿着 next 访问节点，而节点地址不一定是依次连续分配的，在内存中可能需要多次翻页
  - 引用类型
    - 引用类型的值即变量的位
    - 高效列表：使用基本类型实现（长度动态变换）
      - 使用链表实现：+-节点时无需复制，但存在遍历的开销
      - 使用数组实现：高效访问，追加开销大（分配新数组）
      - 实践：具有额外容量的数组，填满时分配一个两倍容量的数组
        - 额外的内存开销
    - 二叉树
      - 使用数组实现：如果数是稀疏的，就需要额外的空间（1, , 3, ,），通常要借助引用来使用更加紧凑的表示
    - 关联数组（字典、哈希表）：键值对集合



## 章三：组合

- 复合类型、多选一、代数数据类型
- 组合类型：对各个可能的取值排列组合
- 元组类型：特殊的分组数据的方式，将不同类型的多个值作为一个值传递
  - 元组也可以通过自己创建 Class，总之就是内容类型固定？
- 记录类型：通过键名来访问，Record！
  - 元组可能造成错误的解释
- 不变量：使成员私有，但提供修改的方法对外暴露
  - 对值的校验与异常处理
- 组合类型
  - 感觉有点像模板字符串类型的配列组合？
- 枚举
- 可选类型
  - T | undefined，即 Optional？
    - 保存类型 T 的一个值或使用一个特殊值在 T 不存在时兜底
  - nullable
  - 清晰地区分可为空的情况
  - 不要让 null 成为类型的子集
- Either 类型
  - 要么返回错误，要么返回结果
- 变体类型
  - 即可辨识联合类型
    - 可辨识属性 >>> 类型索引
- 访问者模式
- 代数数据类型：AlgebraicData Type
  - 乘积类型：元组、记录  A * B * C 进行组合
  - 和类型：联合类型 A | B（也可以通过 never 实现）

## 章四：类型安全

- 避免错误的解释
- 缩小可能的取值集合
- 手动添加信息：类型断言、注解
- 类型 Wrapper：如 1000 美元与 1000 公里，new Currency
- Again：使用 unique symbol 避免错误的结构化类型相等判断
- 反模式：存在更好替代的低效设计，如基本类型偏执就是反模式
- 使用构造函数、工厂模式实现基本类型 Wrapper
- 类型断言
  - 使用 unknown 来作为一个重叠类型
  - 使用一个额外的属性来跟踪类型
- 类型转换
  - 向上转换：需要基类的地方总是可以使用子类（将派生类解释为基类）
    - 里氏替换
  - 向下转换：将基类解释为特定的派生类，通常不会自动完成，需要显式的转换
    - 并不安全
    - 部分语言的运行时也存储了额外的类型信息，因此才能够更安全的实现向下转换
- Widening：
  - 8位无符号 >>> 16位无符号（后者可以表示所有前者）
- Narrowing：
  - 16位无符号 >>> 8位无符号 仅用于小类型
    - 需要显式，具有危险性！
- 隐藏与恢复类型信息
  - 同构集合：相同类型的项，无需隐藏类型信息
  - 异构集合：如一个基类的三个派生类，使用基类类型的列表存储，则就是隐藏了类型信息，在实际使用时需要再向下转换
    - 或者，使用和类型来创建这三个派生类的联合类型，但这需要实际的判断或者使用索引跟踪实际类型
- 序列化与反序列化时的类型



## 章五：函数类型

- 策略模式
  - 就像我之前的 installStrategy.installDep ?
- 一等函数
  - 即函数具有一等支持：类型、赋值、实参、校验等
- 状态机
  - 将类的属性定义为函数类型，通过像此属性进行函数赋值实现在运行时的灵活切换
    - foo.m = m1 >>> foo.m()
  - 状态集合 >>> 枚举，跟踪当前状态并通过遍历 switch case 语句切换到对应的行为，状态并没有和每种状态下独有的逻辑强关联起来，所以可以跨状态调用
    - 如果不使用 switch case 语句，则只需要直接替换此 processor 方法，这样就不再需要跟踪状态，但这会使得无法显式的声明状态发生了转移
    - 类似的，将每种状态表达为一个类，依赖一个额外的变量跟踪状态的转移，会带来额外的代码
- 延迟计算
  - 存储函数，并按需调用开销较大的计算
    - “寄希望于可能根本不需要进行这样的计算”
  - 全部准备好，再决定用哪个 vs 决定用哪个了再准备
  - 匿名函数 lambda：
    - 只需要引用一次，所以不需命名
    - 像数据一样被处理
    - chooseRide(new Bike(), () => new Car())
- 高阶函数：接受低阶函数作为入参
- 代数结构：一个接受 T 类型作为实参，使用 T 类型作为返回值类型的函数类型，则成为 T 值集合上的一个操作，如 (x: number, y:number) => x + y 构成了一个代数结构
  - 单位元：T的一个元素 id，op(x, id) == op(id, x) == x，将id与其他任何元素合并起来，并不会改变其他元素。当集合为number，操作为加法时，单位元是0；当集合为number，操作是乘法时，单位元是1；当集合为string，操作为字符串连接时，单位元是“　”（空字符串）
  - 相关性是操作的一个属性，表明对元素序列应用操作的顺序并不重要，因为最终结果是相同的。即对于T类型的任何x, y,z，有op(x, op(y, z)) == op(op(x, y), z)。例如，对于数字加法和乘法，这种属性成立，但是对于减法或者前面的“连接两个字符串的首字母”，这种属性不成立。
  - 如果集合T上的操作op有一个单位元，并且具有相关性，那么得到的代数结构称为幺半群（monoid）。对于幺半群，将单位元作为初始值，从左向右或者从右向左进行缩减将得到相同的结果。我们甚至可以不要求提供初始值，而是在集合为空时默认使用单位元。还可以并行执行缩减操作。我们可以并行缩减集合的前半部分和后半部分，然后合并结果，因为相关性属性保证了我们将得到相同的结果。对于[1, 2, 3, 4, 5, 6]，我们可以同时合并1 + 2 + 3及4 + 5 + 6，然后把结果加到一起。一旦失去其中一个属性，就失去了这种保证。如果没有相关性，而只有集合、操作和单位元，那么虽然我们仍然不需要有一个初始值（可以使用单位元），但是应用操作的方向就变得重要起来。如果没有单位元，但是有相关性，就得到了一个半群。没有单位元时，把初始值放到第一个元素的左边或者最后一个元素的右边，就变得重要起来。
  - 如果集合T上的操作op有一个单位元，并且具有相关性，那么得到的代数结构称为幺半群（monoid）。对于幺半群，将单位元作为初始值，从左向右或者从右向左进行缩减将得到相同的结果。我们甚至可以不要求提供初始值，而是在集合为空时默认使用单位元。还可以并行执行缩减操作。我们可以并行缩减集合的前半部分和后半部分，然后合并结果，因为相关性属性保证了我们将得到相同的结果。对于[1, 2, 3, 4, 5, 6]，我们可以同时合并1 + 2 + 3及4 + 5 + 6，然后把结果加到一起。一旦失去其中一个属性，就失去了这种保证。如果没有相关性，而只有集合、操作和单位元，那么虽然我们仍然不需要有一个初始值（可以使用单位元），但是应用操作的方向就变得重要起来。如果没有单位元，但是有相关性，就得到了一个半群。没有单位元时，把初始值放到第一个元素的左边或者最后一个元素的右边，就变得重要起来。
  - 如果集合T上的操作op有一个单位元，并且具有相关性，那么得到的代数结构称为幺半群（monoid）。对于幺半群，将单位元作为初始值，从左向右或者从右向左进行缩减将得到相同的结果。我们甚至可以不要求提供初始值，而是在集合为空时默认使用单位元。还可以并行执行缩减操作。我们可以并行缩减集合的前半部分和后半部分，然后合并结果，因为相关性属性保证了我们将得到相同的结果。对于[1, 2, 3, 4, 5, 6]，我们可以同时合并1 + 2 + 3及4 + 5 + 6，然后把结果加到一起。一旦失去其中一个属性，就失去了这种保证。如果没有相关性，而只有集合、操作和单位元，那么虽然我们仍然不需要有一个初始值（可以使用单位元），但是应用操作的方向就变得重要起来。如果没有单位元，但是有相关性，就得到了一个半群。没有单位元时，把初始值放到第一个元素的左边或者最后一个元素的右边，就变得重要起来。
- 函数式编程
